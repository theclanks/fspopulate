// =====================================================================================
// 
//       Filename:  fspopulate.cc
// 
//    Description:  Tool to create a random amount of files filled with pseudorandom
//                  data stored in a random amount of directories with varying depth
//                  levels. Random numbers are generated by a Mersenne Twister algorithm
//                  (see SFMT subdirectory for the code).
// 
//        Version:  1.0
//        Created:  16/07/08 23:52:55 CEST
//       Revision:  none
//       Compiler:  g++
// 
//         Author:  R. Pfeiffer (Mr), lynx@luchs.at
//        Company:  http://web.luchs.at/
// 
// =====================================================================================

//----------------------------------------------------------------------
//  Includes
//----------------------------------------------------------------------

#include <boost/filesystem/convenience.hpp>
#include <boost/filesystem/operations.hpp>
#include <boost/filesystem/path.hpp>
#include <boost/program_options.hpp>

#include <fstream>
#include <iomanip>
#include <iostream>
#include <algorithm>
#include <iterator>

#include <errno.h>
#include <limits.h>
#include <malloc.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <time.h>

#include "SFMT/SFMT.h"
// This include is only needed to print out some settings from the 
// PRNG when in debug mode. You can leave it out when using the PRNG
// without needing this.
#include "SFMT/SFMT-params.h"

using namespace std;
using namespace boost;
namespace popt = boost::program_options;
namespace fs   = boost::filesystem;

//----------------------------------------------------------------------
// Definitions
//----------------------------------------------------------------------

//----------------------------------------------------------------------
// Globals for programme options and tracking of directory depth
//----------------------------------------------------------------------
unsigned int   opt_debug              = 0;
unsigned int   opt_dirlevels          = 16;
string         opt_logfile            = "fspopulate.log";
unsigned int   opt_max_filesize       = INT_MAX/2;
unsigned short opt_max_namelength     = 100;
unsigned int   opt_number_directories = 512;
unsigned int   opt_number_files       = 1024;
string         opt_path               = "/tmp/test";
bool           opt_quiet              = false;

fs::path top_directory;

char *file_buffer;
unsigned int file_buffer_size;

//----------------------------------------------------------------------
//  Strategy
//----------------------------------------------------------------------
// Thanks to Ben Okopnik <ben@linuxgazette.net> for sending a small Bash
// script. This is the more elaborate and quite pointless version. :-)
//
// - We cd into the path that should be populated.
// - We create a random amount of files with random name and content
// - We create a random amount of directories with random names
// - We recursively step into every directory and do the above steps (creating
//   random files and content).
//   - We return if we have reached the desired directory depth.
//

//----------------------------------------------------------------------
//  Templates
//----------------------------------------------------------------------
// A helper function to simplify the main part (taken from the Boost
// programme options examples).
template<class T>
ostream& operator<<(ostream& os, const vector<T>& v)
{
    copy(v.begin(), v.end(), ostream_iterator<T>(cout, " "));
    return os;
}

//----------------------------------------------------------------------
//  Functions
//----------------------------------------------------------------------

// ===  FUNCTION  ======================================================================
//         Name:  create_random_string()
//  Description:  Creates a random string with variable length.
// =====================================================================================
__inline__ string create_random_string( unsigned short max_length ) {
    unsigned short length;
    const string letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    size_t n;
    string random;

    length = (gen_rand32() % max_length)+1;
    for ( n=1; n<=length; n++ ) {
        random.append( letters, gen_rand32() % letters.size(), 1 );
    }

    return(random);
}

// ===  FUNCTION  ======================================================================
//         Name:  init_prng()
//  Description:  Initialises internal PRNG
// =====================================================================================
void init_prng( uint32_t perturb ) {
    struct timeval now;
    uint32_t seed;

    // Inititialise random number generator.
    gettimeofday( &now, NULL );
    seed = (uint32_t)now.tv_usec;
    if ( perturb != 0 ) {
        seed %= perturb;
    }
    init_gen_rand(seed);

    return;
}

// ===  FUNCTION  ======================================================================
//         Name:  create_random_file()
//  Description:  Creates a random file of random size with a random name of random length.
//                The parameters are the limits for the size and the name length. The
//                file is created in the current directory.
// =====================================================================================
bool create_random_file( unsigned int max_size, unsigned short max_length ) {
    unsigned int chunk_size;
    unsigned int bytes_written = 0;
    string name;
    ofstream newfile;
    unsigned int size;
    bool rc = true;

    name = create_random_string( max_length );
    size = (gen_rand32() % max_size)+1;
    // If we use fill_arrayXX() after having called gen_randXX() we have to reinit the
    // PRNG (the source says implicitly "use as directed" although it took me several
    // core dumps to find out).
    init_prng((uint32_t)size);
    newfile.open( name.c_str(), ios::out|ios::binary|ios::trunc );
    if ( newfile.is_open() ) {
        do {
            // Don't forget to adjust the size, because fill_array64() assumes the buffer
            // to be an array of uint64_t values!
            fill_array64( (uint64_t *)file_buffer, file_buffer_size/sizeof(uint64_t) );
            chunk_size = size-bytes_written;
            if ( chunk_size > file_buffer_size ) {
                chunk_size = file_buffer_size;
            }
            if ( chunk_size != 0 ) {
                newfile.write( (const char *)file_buffer, (streamsize)chunk_size );
                bytes_written += chunk_size;
            }
            else {
                bytes_written++;
            }
        } while ( bytes_written <= size );
        newfile.close();
    }
    else {
        rc = false;
    }

    return(rc);
}

bool create_random_directory( unsigned short max_name_length ) {
    bool rc = true;

    return(rc);
}

void populate( fs::path path, unsigned int level ) {
    unsigned int i;
    unsigned int depth_level;
    string dirname;
    string fullpath;
    unsigned int nr_directories;
    unsigned int nr_files;
    unsigned int size;

    fullpath = path.root_directory() + path.relative_path().string();
    if ( opt_debug > 0 ) {
        cout << "DEBUG: Entering <" << fullpath.c_str() << ">" << endl;
    }
    if ( chdir( fullpath.c_str() ) != 0 ) {
        cerr << "ERROR: Cannot chdir into directory <" << fullpath.c_str() << "> (" << strerror(errno) << ")" << endl
             << "ERROR: Level " << level << endl;
        return;
    }
 
    // Keep track of directory depth level
    depth_level = level+1;

    // Create files in current directory
    nr_files = (gen_rand32() % opt_number_files)+1;
    for ( i=1; i<=nr_files; i++ ) {
        size = gen_rand32() % opt_max_filesize;
        if ( ! create_random_file( size, opt_max_namelength ) ) {
            cerr << "ERROR: Cannot create file (" << strerror(errno) << "). Aborting." << endl;
            return;
        }
    }

    // Check for depth, we only create directories when not scratching the depth limit.
    if ( depth_level < opt_dirlevels ) {
        // Create random number of directories
        nr_directories = (gen_rand32() % opt_number_directories)+1;
        for ( i=1; i<=nr_directories; i++ ) {
            // Create name & directory
            dirname = create_random_string(opt_max_namelength);
            if ( mkdir( dirname.c_str(), S_IRWXU|S_IRWXG|S_IROTH|S_IXOTH ) != -1 ) {
                // Populate directory
                fs::path newpath = path / dirname;
                if ( opt_debug > 0 ) {
                    cout << "DEBUG: New path <" << newpath.root_directory() + newpath.relative_path().string() << ">" << endl;
                }
                populate( newpath, depth_level );
                // Change to upper directory again. This is important since populate() chdirs into
                // a deeper directory and we can't climb up again if we don't do a second chdir()
                // after the function returns.
                if ( chdir( fullpath.c_str() ) != 0 ) {
                    cerr << "ERROR: Cannot chdir into directory <" << fullpath.c_str() << "> (" << strerror(errno) << ")" << endl;
                }
            }
            else {
                cerr << "ERROR: Cannot create directory (" << strerror(errno) << "). Aborting." << endl;
                return;
            }
        }
    }

    return;
}

//----------------------------------------------------------------------
//  M A I N
//----------------------------------------------------------------------

int main(int argc, char **argv) {
    int            rc = 0;
    popt::variables_map vm;

    try {
        // Define options and help texts.
        popt::options_description desc("Options for fspopulate");
        desc.add_options()
            ("debug,d", popt::value<unsigned int>(&opt_debug)->default_value(0), "Set debug level of the code.")
            ("dirlevels,D", popt::value<unsigned int>(&opt_dirlevels)->default_value(16), "Set maximum number of directory levels.")
            ("help,h", "Show a short help message with explanations.")
            ("logfile,l", popt::value(&opt_logfile), "Log file for recording information.")
            ("maxfilesize", popt::value<unsigned int>(&opt_max_filesize)->default_value(INT_MAX/2), "Maximum size of created files.")
            ("maxnamelen", popt::value<unsigned short>(&opt_max_namelength)->default_value(100), "Maximum length of file and directory names.")
            ("numdirs", popt::value<unsigned int>(&opt_number_directories)->default_value(512), "Maximum number of created directories.")
            ("numfiles", popt::value<unsigned int>(&opt_number_files)->default_value(1024), "Maximum number of created files.")
            ("path,p", popt::value(&opt_path), "Path to directory that is to be populated.")
            ("quiet,q", popt::bool_switch(&opt_quiet), "Be quiet about the whole operation.")
        ;
        // Parse command line and extract options
        popt::store(popt::parse_command_line(argc, argv, desc), vm);
        popt::notify(vm);

        // Check for help option.
        if ( vm.count("help") > 0 ) {
            cout << desc << endl;
            return(rc);
        }

        // Validate other options.
        if ( (vm.count("debug") > 0) or (vm.count("d") > 0) ) {
            opt_debug = vm["debug"].as<unsigned int>();
        }
        if ( (vm.count("dirlevels") > 0) or (vm.count("D") > 0) ) {
            opt_dirlevels = vm["dirlevels"].as<unsigned int>();
        }
        if ( (vm.count("logfile") > 0) or (vm.count("l") > 0) ) {
            opt_logfile = vm["logfile"].as<string>();
        }
        if ( vm.count("maxfilesize") > 0 ) {
            opt_max_filesize = vm["maxfilesize"].as<unsigned int>();
        }
        if ( vm.count("maxnamelen") > 0 ) {
            opt_max_namelength = vm["maxnamelen"].as<unsigned short>();
        }
        if ( vm.count("numdirs") > 0 ) {
            opt_number_directories = vm["numdirs"].as<unsigned int>();
        }
        if ( vm.count("numfiles") > 0 ) {
            opt_number_files = vm["numfiles"].as<unsigned int>();
        }
        if ( (vm.count("path") > 0) or (vm.count("p") > 0) ) {
            opt_path = vm["path"].as<string>();
        }
        if ( (vm.count("quiet") > 0) or (vm.count("q") > 0) ) {
            opt_quiet = true;
        }

        // Check for debug level.
        if ( opt_debug > 0 ) {
            cout << "Debug mode enabled. Writing diagnostic messages to stdout."  << endl << endl
                 << "/======================================================" << endl 
                 << setw(35) << left << "|Debug level:"                    << setw(30) << opt_debug << endl
                 << setw(35) << left << "|Directory levels:"               << setw(30) << opt_dirlevels << endl
                 << setw(35) << left << "|Log file:"                       << setw(30) << opt_logfile << endl
                 << setw(35) << left << "|Maximum file size:"              << setw(30) << opt_max_filesize << endl
                 << setw(35) << left << "|Maximum length of file names:"   << setw(30) << opt_max_namelength << endl
                 << setw(35) << left << "|Maximum number of directories:"  << setw(30) << opt_number_directories << endl
                 << setw(35) << left << "|Maximum number of files:"        << setw(30) << opt_number_files << endl
                 << setw(35) << left << "|Path:"                           << setw(30) << opt_path << endl
                 << setw(35) << left << "|Quiet option:"                   << setw(30) << opt_quiet << endl
                 << "\\======================================================" << endl << endl << endl;
        }
    }
    catch (std::exception& eh) {
        cerr << eh.what() << endl;
        rc = 1;
    }

    // Inititialise Mersenne Twister pseudorandom number generator (0 means to
    // use the current timestamp as initialisation vector).
    init_prng(0);

    // Initialise file I/O buffer for blockwise generation of random numbers.
    // The PRNG code tells us a minimal buffer size which we will multiply to
    // increase.
    file_buffer_size  = (unsigned int)get_min_array_size64();
    file_buffer_size *= 256;
    file_buffer       = (char *)memalign(16, file_buffer_size);
    if ( file_buffer == NULL ) {
        cerr << "ERROR: Cannot allocate aligned file I/O buffer of " << file_buffer_size << " bytes." << endl;
        rc = 10;
        return(rc);
    }
    if ( opt_debug > 0 ) {
        cout << "DEBUG: File buffer size is " << file_buffer_size << " bytes." << endl;
        cout << "DEBUG: (MEXP / 128 + 1) = " << N << endl;
        cout << "DEBUG: N32              = " << N32 << endl;
        cout << "DEBUG: N64              = " << N64 << endl;
    }

    top_directory = fs::system_complete( opt_path );
    if ( ! fs::is_directory(top_directory) ) {
        cerr << "ERROR: " << opt_path << " is no directory. Please create it." << endl;
        rc = 10;
        return(rc);
    }

    // Call populate() function.
    populate( top_directory, 0 );

    // Free file I/O buffer.
    free((void *)file_buffer);

    return(rc);
}

// __END__
